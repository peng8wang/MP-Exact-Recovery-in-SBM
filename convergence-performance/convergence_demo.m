
clearvars; clc;

%% Basic setting
n = 2000;   %%% n = the number of nodes
K = 2;      %%% K = the number of blocks
m = n/K;    %%% m = the community size

%% ground truth 
Xt =  kron(eye(K), ones(m)); Xt(Xt==0)=-1; %%% Xt = the true cluster matrix
xt = [ones(m,1); -ones(m,1)];              %%% xt = the true cluster vector

%% generate an adjacency matrix A by Binary SBM
b = 16;     %%%  choose the constants beta in q

%% choose the running algorithm
run_PPM = 1; run_MGD = 1; run_GPM = 0; %%% 1 = run the method; 0 = don't run the method
self_loops = 0; %%% 1 = self_loops; 0 = no self_loops 

%% total running time
[ttime_PPM, ttime_MGD, ttime_GPM] = deal(0); max_iter_MGD = 0;

for repeat = 1:5 %%%% 
            
            a = (sqrt(b)+sqrt(2))^2 + repeat;  %%%  choose the constants alpha in p
            p = a*log(n)/n;       %%%  p = the within-cluster connecting probability
            q = b*log(n)/n;       %%%  q = the across-cluster connecting probability       
            Ans11 = rand(m); Al11 = tril(Ans11,-1); 
            As11 = Al11 + Al11'+diag(diag(Ans11)); clear Ans11 Al11
            A11 = double(As11<=p); A11 = sparse(A11); clear As11
            As12 = rand(m);
            A12 = double(As12<=q); A12 = sparse(A12); clear As12
            Ans22 = rand(m); Al22 = tril(Ans22,-1); 
            As22 = Al22 + Al22' + diag(diag(Ans22)); clear Ans22 Al22
            A22 = double(As22<=p); A22 = sparse(A22); clear As22
            A = ([A11,A12;A12',A22]); clear A11 A12 A22
            if self_loops == 0
                A = A - diag(diag(A));
            end
            A = sparse(A);

            %% initial point generated by uniform distribution over the sphere
            Q = randn(n,2); Q0 = Q*(Q'*Q)^(-0.5);
            
            %% choose the parameters in PPM, GPM, and MGD
            maxiter = 2e2; tol = 1e-4; report_interval = 1; total_time = 1e3; print = 1;
            
            %% PPM for MLE
            if run_PPM == 1
                opts = struct('T', maxiter, 'tol', tol, 'report_interval', report_interval,...
                    'total_time', total_time, 'print', print); 
                tic; [x_PPM, iter_PPM, fval_collector_PPM, itergap_PPM] = PPM(A, Q0, xt, opts); time_PPM=toc; 
                ttime_PPM = ttime_PPM + time_PPM;
                dist_PPM = norm(x_PPM*x_PPM'-Xt, 'fro');
            end
            
            %% GPM for Regularized MLE
            if run_GPM == 1
                rho = sum(sum(A))/n^2; x0 = sqrt(n)*Q0(:,2);
                opts = struct('T', maxiter, 'rho', rho, 'tol', tol, 'report_interval', report_interval,...
                    'total_time', total_time, 'print', print); 
                tic; [x_GPM, iter_GPM, fval_collector_GPM, itergap_GPM] = GPM(A, x0, xt, opts); time_GPM=toc; 
                ttime_GPM = ttime_GPM + time_GPM;
                dist_GPM = norm(x_GPM*x_GPM'-Xt, 'fro');
            end 
            
            
            %% Manifold Gradient Descent
            if run_MGD == 1
                rho = (p+q)/2;
                opts = struct('rho', rho, 'T', maxiter, 'tol', tol, 'report_interval', report_interval,...
                    'total_time', total_time, 'print', print);                
                tic; [Q, iter_MGD, fval_collector_MGD, itergap_MGD] = manifold_GD(A, Q0, xt, opts); time_MGD=toc;
                ttime_MGD = ttime_MGD + time_MGD;
                dist_MGD =  norm(Q*Q'-Xt, 'fro');
            end
            
            %% plot convergence performance            
            if repeat == 1
                color = [0, 0.4470, 0.7410];
            elseif repeat ==2 
                color = [0.8500, 0.3250, 0.0980];
            elseif repeat == 3 
                color = [0.9290, 0.6940, 0.1250];
            elseif repeat == 4 
                color = [0.4940, 0.1840, 0.5560];
            else
                color = [0.4660, 0.6740, 0.1880];
            end
            
            if run_PPM == 1
                n1 = size(itergap_PPM, 2);
                semilogy(itergap_PPM(1:n1-1)+2e-8, '-s', 'Color', color,...
                     'DisplayName', ['PPM on data ' num2str(repeat) ''], 'LineWidth', 2, 'MarkerSize', 6); hold on;
            end
            if run_GPM == 1
                n1 = size(itergap_GPM, 2);
                semilogy(itergap_GPM(1:n1-1)+2e-8, '-o', 'Color', color,...
                     'DisplayName', ['GPM on data ' num2str(repeat) ''], 'LineWidth', 2, 'MarkerSize', 6); hold on;
            end
            if run_MGD == 1
                n1 = size(itergap_MGD, 2); 
                semilogy(itergap_MGD(1:n1-3)+2e-8, '-*', 'Color', color,...
                    'DisplayName', ['MGD on data ' num2str(repeat) ''], 'LineWidth', 2, 'MarkerSize', 6); hold on;
            end

            max_iter_MGD = max(iter_MGD,max_iter_MGD);

end 
legend('show');
xlim([0, round(max_iter_MGD*1.05)]); 

if b == 2
    ylim([1e-8, 1e4]); title('\beta = 2'); 
elseif b == 4
    ylim([1e-8, 1e5]); title('\beta = 4');
elseif b == 8
    ylim([1e-8, 1e5]); title('\beta = 8');
elseif b == 16
    ylim([1e-8, 1e5]); title('\beta = 16');
else
    ylim([1e-8, 1e5]); title('\beta = 32');
end

xlabel('Iterations'); ylabel('distance to ground truth');


